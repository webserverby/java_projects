* * * * * * * * * * * * * * * * * * * * * * * * ПОЛЕЗНОСТИ/СОВЕТЫ * * * * * * * * * * * * * * * * * * * * * * * * * * *
*
* WEB-INF - это внутренняя директория tomcat-а, и в случае, если попыться через url, зайти в какой-то файл в папке
* * * WEB-INF, то tomcat заблокирует доступ. Все родительские папки доступны и к их файлам можно обратиться через url,
* * * поэтому, в случае, если есть файлы содержающие пароли и т.д., то необходимо их ложить внутрь папки WEB-INF.
*
* Для работы с интерфейсом Filter приходиться всегда переопределять все его методы для реализации своего фильтра.
* * * Чтобы немного упростить себе задачу, можно создать абстратный класс BaseFilter, какой будет себя разширять с
* * * помощью как раз этого интерфейса Filter. Таким образом при создании своего фильтра можно унаследоваться от класса
* * * BaseFilter и после переопределять в свой класс только нужные методы.
* * * Также, можно в базовом абстрактном классе фильтра создать абстрактный метод doFilter, какой будет в точности как
* * * метод doFilter() с интерфейса Filter, только в базовом методе сделать приведение всех типов ServletRequest и
* * * ServletResponse, к более точным: HttpServletRequest, HttpServletResponse, и в нем вызвать абстраткный метод
* * * doFilter(). (Использование таких правил считается хорошим стилем программирования.)
* * * Выглядит это так:
* * *  @Override
* * *  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
* * *      doFilter((HttpServletRequest) request, (HttpServletResponse) response, chain);
* * *  }
* * *
* * *  public abstract void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException;
*
* Servlets - это реализация шаблона проектирования MVC.
* * * Servlet - это контроллер (controller), JSP - визуальное представление (view).
*
* RequestDispatcher, это класс какой говорит куда направится дальше, передать путь другому сервлету или просто задать
* * * путь на какой-то jsp-файл. Этот класс прежде всего обращается к web.xml. Оттуда считывает данные и относительно
* * * заданного пути передает работу другой вьюхе или контроллеру.
* * * Подробнее:
* * * // Переменной page присваиваем путь к нужному файлу.
* * * RequestDispatcher page = request.getRequestDispatcher("a/b/c.jsp");
* * * // После вызываем метод для перехода к этому файлу.
* * * page.forward(request, response);
* * *
* * * После вызова метода forward класса RequestDispatcher категорически не рекомендуется снова обращаться к параметрам
* * * текущего метода doFilter(): request и response.
*
* request - от него можно получить только данные какие приходят от клиента.
*
* response - передача информации клиенту.
*
* response.sendError(<Номер ошибки>); // сгенерировать ошибку под нужным номером, к примеру: 404.
*
* response.sendRedirect("<путь к фвйлу, к какому нужно перенаправить клиента>");
* * * Также, этот вызов пересикает границы контейнера. При вызове он генерирует ответ браузеру "302" и просит
* * * перенаправить клиента на нужный url. (И браузер относится к осторожностью к редиректам)
*
* Через всю цепочку фильтров и сервлетов всегда идет одна и та же пара request, response. Таким образом, если мы
* * * передадим например какой-нибудь атрибут, то после перехода к другим фильтрам или сервлету мы можем к нему
* * * обратиться.
*
* Если в web.xml внутри тега servlet, filter или listener внести тег load-on-startup, этот тег будет отвечать за очередь
* * * создания данного сервлета, фильтра или листенера во время подъема приложения.
* * * (Чем число меньше, тем раньше будет создан.)
*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *